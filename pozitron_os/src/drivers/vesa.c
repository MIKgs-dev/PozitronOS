#include "drivers/vesa.h"
#include "drivers/serial.h"
#include "drivers/ports.h"
#include <stdint.h>
#include <stddef.h>
#include "kernel/memory.h"
#include "kernel/multiboot.h"

// Шрифт 8x16 (первые 128 символов ASCII)
static const uint8_t font_8x16[2048] = {
    // Пробел (32) 0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33) 16
    0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // " (34) 32
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // # (35) 48
    0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // $ (36) 64
    0x18, 0x18, 0x7C, 0xC6, 0xC0, 0x78, 0x0C, 0x06, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // % (37) 80
    0x00, 0x00, 0x00, 0xC6, 0xCC, 0x18, 0x30, 0x60, 0xCE, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // & (38) 96
    0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ' (39) 112
    0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ( (40) 128
    0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ) (41) 144
    0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // * (42) 160
    0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // + (43) 176
    0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // , (44) 192
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // - (45) 208
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // . (46) 224
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // / (47) 240
    0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0 (48) 256
    0x00, 0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 1 (49) 272
    0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 2 (50) 288
    0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 3 (51) 304
    0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 4 (52) 320
    0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 5 (53) 336
    0x00, 0xFE, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 6 (54) 352
    0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 7 (55) 368
    0x00, 0xFE, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 8 (56) 384
    0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 9 (57) 400
    0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // : (58) 416
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ; (59) 432
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // < (60) 448
    0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
    // = (61) 464
    0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // > (62) 480
    0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ? (63) 496
    0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // @ (64) 512
    0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // A (65) 528
    0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // B (66) 544
    0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // C (67) 560
    0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // D (68) 576
    0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // E (69) 592
    0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // F (70) 608
    0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // G (71) 624
    0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // H (72) 640
    0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // I (73) 656
    0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // J (74) 672
    0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // K (75) 688
    0x00, 0xE6, 0x66, 0x6C, 0x6C, 0x78, 0x6C, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // L (76) 704
    0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // M (77) 720
    0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // N (78) 736
    0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // O (79) 752
    0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // P (80) 768
    0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Q (81) 784
    0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00, 0x00, 0x00,
    // R (82) 800
    0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // S (83) 816
    0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // T (84) 832
    0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // U (85) 848
    0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // V (86) 864
    0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // W (87) 880
    0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // X (88) 896
    0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Y (89) 912
    0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Z (90) 928
    0x00, 0xFE, 0xC6, 0x8C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // [ (91) 944
    0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // \ (92) 960
    0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ] (93) 976
    0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ^ (94) 992
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // _ (95) 1008
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
    // ` (96) 1024
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // a (97) 1040
    0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // b (98) 1056
    0x00, 0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // c (99) 1072
    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // d (100) 1088
    0x00, 0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // e (101) 1104
    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // f (102) 1120
    0x00, 0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // g (103) 1136
    0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00, 0x00, 0x00,
    // h (104) 1152
    0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // i (105) 1168
    0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // j (106) 1184
    0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
    // k (107) 1200
    0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // l (108) 1216
    0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // m (109) 1232
    0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // n (110) 1248
    0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // o (111) 1264
    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // p (112) 1280
    0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
    // q (113) 1296
    0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00,
    // r (114) 1312
    0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // s (115) 1328
    0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x70, 0x1C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // t (116) 1344
    0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // u (117) 1360
    0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // v (118) 1376
    0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // w (119) 1392
    0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // x (120) 1408
    0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // y (121) 1424
    0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00, 0x00, 0x00,
    // z (122) 1440
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // { (123) 1456
    0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // | (124) 1472
    0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // } (125) 1488
    0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ~ (126) 1504
    0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // DEL (127) 1520
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Русский шрифт 8x16 (CP866 кодировка, 64 символа)
static const uint8_t font_8x16_rus[1024] = {
    // А (192/0x80)
    0x00, 0x00, 0x18, 0x18, 0x24, 0x24, 0x42, 0x42,
    0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00,
    // Б (193/0x81)
    0x00, 0x00, 0x7C, 0x40, 0x40, 0x40, 0x78, 0x44,
    0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00,
    // В (194/0x82)
    0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x78, 0x44,
    0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00,
    // Г (195/0x83)
    0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x40, 0x40,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
    // Д (196/0x84)
    0x00, 0x00, 0x0C, 0x14, 0x14, 0x24, 0x24, 0x44,
    0x44, 0x7E, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // Е (197/0x85)
    0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x40,
    0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00,
    // Ж (198/0x86)
    0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x18, 0x18,
    0x24, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // З (199/0x87)
    0x00, 0x00, 0x3C, 0x42, 0x02, 0x02, 0x0C, 0x02,
    0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00,
    // И (200/0x88)
    0x00, 0x00, 0x42, 0x42, 0x46, 0x4A, 0x52, 0x62,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // Й (201/0x89)
    0x24, 0x18, 0x42, 0x42, 0x46, 0x4A, 0x52, 0x62,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // К (202/0x8A)
    0x00, 0x00, 0x42, 0x44, 0x48, 0x50, 0x60, 0x50,
    0x48, 0x44, 0x44, 0x42, 0x42, 0x00, 0x00, 0x00,
    // Л (203/0x8B)
    0x00, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x42, 0x00, 0x00, 0x00,
    // М (204/0x8C)
    0x00, 0x00, 0x42, 0x66, 0x66, 0x5A, 0x5A, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // Н (205/0x8D)
    0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // О (206/0x8E)
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00,
    // П (207/0x8F)
    0x00, 0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // Р (208/0x90)
    0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
    // С (209/0x91)
    0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x40,
    0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00,
    // Т (210/0x92)
    0x00, 0x00, 0x7F, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,
    // У (211/0x93)
    0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
    0x42, 0x42, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x00,
    // Ф (212/0x94)
    0x00, 0x00, 0x10, 0x38, 0x54, 0x54, 0x54, 0x54,
    0x54, 0x54, 0x38, 0x10, 0x10, 0x00, 0x00, 0x00,
    // Х (213/0x95)
    0x00, 0x00, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18,
    0x24, 0x24, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00,
    // Ц (214/0x96)
    0x00, 0x00, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
    0x44, 0x44, 0x44, 0x7E, 0x02, 0x00, 0x00, 0x00,
    // Ч (215/0x97)
    0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x22,
    0x1E, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00,
    // Ш (216/0x98)
    0x00, 0x00, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
    0x92, 0x92, 0x92, 0x92, 0xFE, 0x00, 0x00, 0x00,
    // Щ (217/0x99)
    0x00, 0x00, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,
    0x92, 0x92, 0x92, 0xFE, 0x02, 0x00, 0x00, 0x00,
    // Ъ (218/0x9A)
    0x00, 0x00, 0xC0, 0x40, 0x40, 0x40, 0x7C, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00,
    // Ы (219/0x9B)
    0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0xF2, 0x8A,
    0x86, 0x86, 0x86, 0x8A, 0xF2, 0x00, 0x00, 0x00,
    // Ь (220/0x9C)
    0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x7C, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00,
    // Э (221/0x9D)
    0x00, 0x00, 0x3C, 0x42, 0x02, 0x02, 0x1E, 0x02,
    0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00,
    // Ю (222/0x9E)
    0x00, 0x00, 0x8C, 0x92, 0x92, 0x92, 0xF2, 0x92,
    0x92, 0x92, 0x92, 0x92, 0x8C, 0x00, 0x00, 0x00,
    // Я (223/0x9F)
    0x00, 0x00, 0x1E, 0x22, 0x42, 0x42, 0x42, 0x22,
    0x1E, 0x12, 0x22, 0x42, 0x42, 0x00, 0x00, 0x00,
    // а (224/0xA0)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x04,
    0x3C, 0x44, 0x44, 0x44, 0x3A, 0x00, 0x00, 0x00,
    // б (225/0xA1)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x40, 0x40,
    0x78, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00,
    // в (226/0xA2)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44,
    0x78, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00, 0x00,
    // г (227/0xA3)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x40, 0x40,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
    // д (228/0xA4)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x14, 0x24,
    0x24, 0x44, 0x7C, 0x44, 0x44, 0x00, 0x00, 0x00,
    // е (229/0xA5)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44,
    0x7C, 0x40, 0x40, 0x44, 0x38, 0x00, 0x00, 0x00,
    // ж (230/0xA6)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x28,
    0x10, 0x28, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // з (231/0xA7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x04,
    0x18, 0x04, 0x04, 0x44, 0x38, 0x00, 0x00, 0x00,
    // и (232/0xA8)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x4C,
    0x54, 0x64, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // й (233/0xA9)
    0x24, 0x18, 0x00, 0x00, 0x00, 0x44, 0x44, 0x4C,
    0x54, 0x64, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // к (234/0xAA)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x48, 0x50,
    0x60, 0x50, 0x48, 0x48, 0x44, 0x00, 0x00, 0x00,
    // л (235/0xAB)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x44, 0x00, 0x00, 0x00,
    // м (236/0xAC)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x6C, 0x6C,
    0x54, 0x54, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // н (237/0xAD)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44,
    0x7C, 0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // о (238/0xAE)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44,
    0x44, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00,
    // п (239/0xAF)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x44, 0x44,
    0x44, 0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // р (240/0xB0)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44,
    0x44, 0x78, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
    // с (241/0xB1)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x40,
    0x40, 0x40, 0x40, 0x44, 0x38, 0x00, 0x00, 0x00,
    // т (242/0xB2)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x10, 0x10,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
    // у (243/0xB3)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44,
    0x44, 0x44, 0x44, 0x24, 0x18, 0x00, 0x00, 0x00,
    // ф (244/0xB4)
    0x00, 0x00, 0x00, 0x10, 0x10, 0x38, 0x54, 0x54,
    0x54, 0x54, 0x38, 0x10, 0x10, 0x00, 0x00, 0x00,
    // х (245/0xB5)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x28,
    0x10, 0x28, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00,
    // ц (246/0xB6)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44,
    0x44, 0x44, 0x44, 0x7C, 0x04, 0x00, 0x00, 0x00,
    // ч (247/0xB7)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44,
    0x44, 0x3C, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    // ш (248/0xB8)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x54, 0x54,
    0x54, 0x54, 0x54, 0x54, 0x7C, 0x00, 0x00, 0x00,
    // щ (249/0xB9)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x54, 0x54,
    0x54, 0x54, 0x54, 0x7C, 0x04, 0x00, 0x00, 0x00,
    // ъ (250/0xBA)
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x40, 0x40,
    0x78, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00, 0x00,
    // ы (251/0xBB)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x84, 0x84,
    0xF4, 0x8C, 0x8C, 0x8C, 0xF4, 0x00, 0x00, 0x00,
    // ь (252/0xBC)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40,
    0x78, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00, 0x00,
    // э (253/0xBD)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44, 0x04,
    0x1C, 0x04, 0x04, 0x44, 0x38, 0x00, 0x00, 0x00,
    // ю (254/0xBE)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0x92, 0x92,
    0xF2, 0x92, 0x92, 0x92, 0x8C, 0x00, 0x00, 0x00,
    // я (255/0xBF)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x24, 0x44,
    0x44, 0x24, 0x1C, 0x14, 0x24, 0x44, 0x00, 0x00
};

// ===== ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И СТРУКТУРЫ =====

#define MAX_DIRTY_RECTS 32
#define BACKGROUND_CACHED 1

struct vbe_mode_info {
    uint16_t attributes;
    uint8_t window_a, window_b;
    uint16_t granularity;
    uint16_t window_size;
    uint16_t segment_a, segment_b;
    uint32_t win_func_ptr;
    uint16_t pitch;
    uint16_t width, height;
    uint8_t w_char, h_char, planes, bpp;
    uint8_t banks, memory_model, bank_size, image_pages;
    uint8_t reserved0;
    uint8_t red_mask, red_position;
    uint8_t green_mask, green_position;
    uint8_t blue_mask, blue_position;
    uint8_t reserved_mask, reserved_position;
    uint8_t direct_color_attributes;
    uint32_t framebuffer;
    uint32_t off_screen_mem_ptr;
    uint16_t off_screen_mem_size;
    uint8_t reserved1[206];
} __attribute__((packed));

static struct fb_info fb = {0};
static void* back_buffer = NULL;  // Изменено с uint32_t* на void*
static uint8_t double_buffer_enabled = 0;

// Dirty rectangles
static dirty_rect_t dirty_rects[MAX_DIRTY_RECTS];
static uint32_t dirty_count = 0;
static uint8_t dirty_system_initialized = 0;

// Кэшированный фон
static uint32_t* background_cache = NULL;
static uint8_t background_cached = 0;

// ===== СИСТЕМА DIRTY RECTANGLES =====

void vesa_init_dirty(void) {
    dirty_count = 0;
    dirty_system_initialized = 1;
    serial_puts("[VESA] Dirty rectangles system initialized\n");
}

void vesa_mark_dirty(uint32_t x, uint32_t y, uint32_t w, uint32_t h) {
    if (!dirty_system_initialized) return;
    
    if (x >= fb.width) return;
    if (y >= fb.height) return;
    if (x + w > fb.width) w = fb.width - x;
    if (y + h > fb.height) h = fb.height - y;
    if (w == 0 || h == 0) return;
    
    for (uint32_t i = 0; i < dirty_count; i++) {
        dirty_rect_t* r = &dirty_rects[i];
        
        if (x >= r->x && y >= r->y && 
            x + w <= r->x + r->w && y + h <= r->y + r->h) {
            return;
        }
        
        if (r->x >= x && r->y >= y && 
            r->x + r->w <= x + w && r->y + r->h <= y + h) {
            r->x = x; r->y = y; r->w = w; r->h = h;
            return;
        }
        
        if (x < r->x + r->w && x + w > r->x &&
            y < r->y + r->h && y + h > r->y) {
            uint32_t new_x = (x < r->x) ? x : r->x;
            uint32_t new_y = (y < r->y) ? y : r->y;
            uint32_t new_w = ((x + w > r->x + r->w) ? x + w : r->x + r->w) - new_x;
            uint32_t new_h = ((y + h > r->y + r->h) ? y + h : r->y + r->h) - new_y;
            
            r->x = new_x; r->y = new_y; r->w = new_w; r->h = new_h;
            return;
        }
    }
    
    if (dirty_count < MAX_DIRTY_RECTS) {
        dirty_rects[dirty_count].x = x;
        dirty_rects[dirty_count].y = y;
        dirty_rects[dirty_count].w = w;
        dirty_rects[dirty_count].h = h;
        dirty_count++;
    } else {
        vesa_mark_dirty_all();
    }
}

void vesa_mark_dirty_all(void) {
    if (!dirty_system_initialized) return;
    
    dirty_count = 1;
    dirty_rects[0].x = 0;
    dirty_rects[0].y = 0;
    dirty_rects[0].w = fb.width;
    dirty_rects[0].h = fb.height;
}

static inline void fast_copy(uint32_t* dst, uint32_t* src, uint32_t words) {
    asm volatile (
        "rep movsl\n"
        : "+D" (dst), "+S" (src), "+c" (words)
        : 
        : "memory"
    );
}

void vesa_update_dirty(void) {
    if (!dirty_system_initialized || !double_buffer_enabled || !back_buffer || !fb.found) {
        return;
    }
    
    uint32_t bytes_per_pixel = fb.bpp / 8;
    
    for (uint32_t i = 0; i < dirty_count; i++) {
        dirty_rect_t* r = &dirty_rects[i];
        
        for (uint32_t y = r->y; y < r->y + r->h && y < fb.height; y++) {
            uint8_t* src = (uint8_t*)back_buffer + y * fb.pitch + r->x * bytes_per_pixel;
            uint8_t* dst = (uint8_t*)fb.address + y * fb.pitch + r->x * bytes_per_pixel;
            uint32_t bytes = r->w * bytes_per_pixel;
            
            for (uint32_t b = 0; b < bytes; b++) {
                dst[b] = src[b];
            }
        }
    }
    
    vesa_clear_dirty();
}

void vesa_clear_dirty(void) {
    dirty_count = 0;
}

uint32_t vesa_get_dirty_count(void) {
    return dirty_count;
}

uint8_t vesa_get_dirty_rect(uint32_t index, uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h) {
    if (index >= dirty_count) return 0;
    
    if (x) *x = dirty_rects[index].x;
    if (y) *y = dirty_rects[index].y;
    if (w) *w = dirty_rects[index].w;
    if (h) *h = dirty_rects[index].h;
    
    return 1;
}

// ===== СИСТЕМА КЭШИРОВАНИЯ ФОНА =====

void vesa_cache_background(void) {
    if (!fb.found || !double_buffer_enabled) return;
    
    size_t buffer_size = fb.width * fb.height * (fb.bpp / 8);
    
    // ОСВОБОЖДАЕМ старый кэш если есть
    if (background_cache) {
        kfree(background_cache);
        background_cache = NULL;
    }
    
    // ВЫДЕЛЯЕМ как void*, потом будем кастовать по необходимости
    background_cache = (uint32_t*)kmalloc(buffer_size);
    
    if (!background_cache) {
        serial_puts("[VESA] WARNING: Failed to cache background\n");
        return;
    }
    
    uint32_t bg_color = 0xC0C0C0;  // Светло-серый
    uint8_t r = (bg_color >> 16) & 0xFF;
    uint8_t g = (bg_color >> 8) & 0xFF;
    uint8_t b = bg_color & 0xFF;
    
    uint32_t bytes_per_pixel = fb.bpp / 8;
    uint8_t* cache = (uint8_t*)background_cache;
    
    if (fb.bpp == 32) {
        // 32-бит: пишем uint32_t
        uint32_t* cache32 = (uint32_t*)cache;
        for (uint32_t i = 0; i < fb.width * fb.height; i++) {
            cache32[i] = bg_color;
        }
    } else if (fb.bpp == 24) {
        // 24-бит: пишем 3 байта на пиксель
        for (uint32_t i = 0; i < buffer_size; i += 3) {
            cache[i] = b;
            cache[i + 1] = g;
            cache[i + 2] = r;
        }
    }
    
    background_cached = 1;
    serial_puts("[VESA] Background cached (");
    serial_puts_num(buffer_size);
    serial_puts(" bytes)\n");
}

void vesa_restore_background(void) {
    if (!background_cached || !background_cache || !back_buffer) return;
    
    size_t total_pixels = fb.width * fb.height;
    fast_copy((uint32_t*)back_buffer, background_cache, total_pixels);
}

void vesa_restore_background_dirty(void) {
    if (!background_cached || !background_cache || !back_buffer || dirty_count == 0) return;
    
    uint32_t bytes_per_pixel = fb.bpp / 8;
    uint8_t* bb = (uint8_t*)back_buffer;
    uint8_t* cache = (uint8_t*)background_cache;
    
    uint32_t cursor_x, cursor_y, cursor_w, cursor_h;
    vesa_cursor_get_area(&cursor_x, &cursor_y, &cursor_w, &cursor_h);
    
    for (uint32_t i = 0; i < dirty_count; i++) {
        dirty_rect_t* r = &dirty_rects[i];
        
        for (uint32_t y = r->y; y < r->y + r->h && y < fb.height; y++) {
            // cache: храним построчно без питча (width * bytes_per_pixel)
            uint32_t cache_offset = y * fb.width * bytes_per_pixel + r->x * bytes_per_pixel;
            
            // back buffer: с учетом питча!
            uint32_t bb_offset = y * fb.pitch + r->x * bytes_per_pixel;
            
            uint32_t copy_bytes = r->w * bytes_per_pixel;
            
            for (uint32_t x = 0; x < copy_bytes; x++) {
                bb[bb_offset + x] = cache[cache_offset + x];
            }
        }
    }
}

void vesa_free_background_cache(void) {
    if (background_cache) {
        kfree(background_cache);
        background_cache = NULL;
        background_cached = 0;
        serial_puts("[VESA] Background cache freed\n");
    }
}

// ===== ОСНОВНЫЕ ФУНКЦИИ VESA =====

static int find_vbe_info(void) {
    serial_puts("[VESA] Scanning for framebuffer (fallback)...\n");
    
    uint32_t test_addresses[] = {0xFD000000, 0xE0000000, 0xB8000000, 0xA0000000};
    
    for(int i = 0; i < 4; i++) {
        serial_puts("[VESA] Testing address 0x");
        uint32_t addr = test_addresses[i];
        char hex[] = "0123456789ABCDEF";
        for(int j = 28; j >= 0; j -= 4) {
            if(addr >> j) serial_write(hex[(addr >> j) & 0xF]);
        }
        serial_puts("... ");
        
        volatile uint32_t* test_fb = (volatile uint32_t*)test_addresses[i];
        uint32_t original = test_fb[0];
        test_fb[0] = 0x00AABBCC;
        asm volatile("" ::: "memory");
        
        if(test_fb[0] == 0x00AABBCC) {
            test_fb[0] = original;
            fb.address = (uint32_t*)test_addresses[i];
            fb.found = 1;
            fb.width = 1024;
            fb.height = 768;
            fb.bpp = 32;
            fb.pitch = fb.width * 4;
            
            serial_puts("FOUND (using 1024x768x32 as fallback)\n");
            return 1;
        }
        serial_puts("NOT FOUND\n");
    }
    
    serial_puts("[VESA] No framebuffer found during scan\n");
    return 0;
}

// ===== ДВОЙНАЯ БУФЕРИЗАЦИЯ =====

int vesa_enable_double_buffer(void) {
    if (!fb.found) {
        serial_puts("[VESA] ERROR: Framebuffer not found\n");
        return 0;
    }
    
    size_t buffer_size = fb.width * fb.height * (fb.bpp / 8);
    
    // ВАЖНО: выделяем как void*, никаких кастов!
    back_buffer = kmalloc(buffer_size);
    
    if (!back_buffer) {
        serial_puts("[VESA] ERROR: Failed to allocate back buffer (");
        serial_puts_num(buffer_size);
        serial_puts(" bytes)\n");
        return 0;
    }
    
    // Очищаем буфер
    uint8_t* buf = (uint8_t*)back_buffer;
    for (size_t i = 0; i < buffer_size; i++) {
        buf[i] = 0;
    }
    
    double_buffer_enabled = 1;
    serial_puts("[VESA] Double buffering enabled (");
    serial_puts_num(buffer_size);
    serial_puts(" bytes)\n");
    return 1;
}

void vesa_disable_double_buffer(void) {
    if (back_buffer) {
        kfree(back_buffer);
        back_buffer = NULL;
    }
    double_buffer_enabled = 0;
    serial_puts("[VESA] Double buffering disabled\n");
}

void vesa_swap_buffers(void) {
    if (!double_buffer_enabled || !back_buffer || !fb.found) return;
    
    uint8_t* fb_ptr = (uint8_t*)fb.address;
    uint8_t* bb_ptr = (uint8_t*)back_buffer;
    
    if (fb.bpp == 32) {
        // 32-бит: rep movsl (быстро)
        uint32_t* dst = (uint32_t*)fb_ptr;
        uint32_t* src = (uint32_t*)bb_ptr;
        uint32_t words = fb.width * fb.height;
        asm volatile ("rep movsl" : "+D"(dst), "+S"(src), "+c"(words) : : "memory");
    } else {
        // 24-бит: копируем по 4 байта, пока можно
        uint32_t bytes_per_line = fb.width * 3;
        uint32_t pitch_diff = fb.pitch - bytes_per_line;
        
        for (uint32_t y = 0; y < fb.height; y++) {
            // Копируем строку по 4 байта
            uint32_t words = bytes_per_line / 4;
            uint32_t* dst = (uint32_t*)fb_ptr;
            uint32_t* src = (uint32_t*)bb_ptr;
            asm volatile ("rep movsl" : "+D"(dst), "+S"(src), "+c"(words) : : "memory");
            
            // Остаток 0-3 байта
            uint32_t rem = bytes_per_line % 4;
            uint8_t* dst8 = (uint8_t*)dst;
            uint8_t* src8 = (uint8_t*)src;
            for (uint32_t i = 0; i < rem; i++) dst8[i] = src8[i];
            
            fb_ptr += fb.pitch;
            bb_ptr += bytes_per_line;
        }
    }
}

void vesa_clear_back_buffer(uint32_t color) {
    if (!double_buffer_enabled || !back_buffer) return;
    
    uint32_t bytes_per_pixel = fb.bpp / 8;
    size_t buffer_size = fb.width * fb.height * bytes_per_pixel;
    uint8_t* buf = (uint8_t*)back_buffer;
    
    // Разбиваем цвет на байты
    uint8_t r = (color >> 16) & 0xFF;
    uint8_t g = (color >> 8) & 0xFF;
    uint8_t b = color & 0xFF;
    
    if (bytes_per_pixel == 4) {
        // 32-бит: пишем uint32_t
        uint32_t* buf32 = (uint32_t*)back_buffer;
        size_t total_pixels = fb.width * fb.height;
        for (size_t i = 0; i < total_pixels; i++) {
            buf32[i] = color;
        }
    } else if (bytes_per_pixel == 3) {
        // 24-бит: пишем 3 байта на пиксель
        for (size_t i = 0; i < buffer_size; i += 3) {
            buf[i] = b;
            buf[i + 1] = g;
            buf[i + 2] = r;
        }
    } else if (bytes_per_pixel == 2) {
        // 16-бит: RGB565
        uint16_t rgb565 = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
        uint16_t* buf16 = (uint16_t*)back_buffer;
        size_t total_pixels = fb.width * fb.height;
        for (size_t i = 0; i < total_pixels; i++) {
            buf16[i] = rgb565;
        }
    }
}

// ===== ИНИЦИАЛИЗАЦИЯ =====

int vesa_init(multiboot_info_t* mb_info) {
    serial_puts("[VESA] Initializing...\n");
    
    for(int i = 0; i < 1000000; i++) asm volatile("nop");
    
    if (mb_info && (mb_info->flags & (1 << 12))) {
        serial_puts("[VESA] Trying to use Multiboot framebuffer info...\n");
        
        fb.address = (uint32_t*)(uintptr_t)mb_info->framebuffer_addr;
        fb.width = mb_info->framebuffer_width;
        fb.height = mb_info->framebuffer_height;
        fb.bpp = mb_info->framebuffer_bpp;
        fb.pitch = mb_info->framebuffer_pitch;
        
        if (fb.address) {
            serial_puts("[VESA] Testing Multiboot framebuffer at 0x");
            uint32_t addr = (uint32_t)fb.address;
            char hex[] = "0123456789ABCDEF";
            for(int j = 28; j >= 0; j -= 4) {
                if(addr >> j) serial_write(hex[(addr >> j) & 0xF]);
            }
            serial_puts("\n");
            
            volatile uint32_t* test_fb = (volatile uint32_t*)fb.address;
            uint32_t original = test_fb[0];
            test_fb[0] = 0x00AABBCC;
            asm volatile("" ::: "memory");
            
            if(test_fb[0] == 0x00AABBCC) {
                test_fb[0] = original;
                fb.found = 1;
                
                serial_puts("[VESA] Multiboot framebuffer verified: ");
                serial_puts_num(fb.width);
                serial_puts("x");
                serial_puts_num(fb.height);
                serial_puts("x");
                serial_puts_num(fb.bpp);
                serial_puts("\n");
                serial_puts("[VESA] Pitch: ");
                serial_puts_num(fb.pitch);
                serial_puts(" bytes\n");
                
                goto init_systems;
            }
        }
        
        serial_puts("[VESA] Multiboot framebuffer verification failed, falling back to scan\n");
    } else {
        serial_puts("[VESA] No Multiboot framebuffer info available\n");
    }
    
    if (!find_vbe_info()) {
        serial_puts("[VESA] ERROR: No framebuffer found!\n");
        return 0;
    }
    
init_systems:
    vesa_fill(0x000000);
    
    if (vesa_enable_double_buffer()) {
        vesa_clear_back_buffer(0x000000);
    }
    
    vesa_cache_background();
    vesa_init_dirty();
    
    serial_puts("[VESA] Framebuffer initialized: ");
    serial_puts_num(fb.width);
    serial_puts("x");
    serial_puts_num(fb.height);
    serial_puts("x");
    serial_puts_num(fb.bpp);
    serial_puts(" (Pitch: ");
    serial_puts_num(fb.pitch);
    serial_puts(")\n");
    
    return 1;
}

// ===== ПРИМИТИВЫ РИСОВАНИЯ =====

void vesa_put_pixel(uint32_t x, uint32_t y, color_t color) {
    if(!fb.found || x >= fb.width || y >= fb.height) return;
    
    uint8_t* buffer;
    if (double_buffer_enabled && back_buffer) {
        buffer = (uint8_t*)back_buffer;
    } else {
        buffer = (uint8_t*)fb.address;
    }
    
    uint32_t bytes_per_pixel = fb.bpp / 8;
    uint32_t offset = y * fb.pitch + x * bytes_per_pixel;
    
    if (bytes_per_pixel == 4) {
        // 32-бит
        uint32_t* buf32 = (uint32_t*)buffer;
        buf32[y * (fb.pitch / 4) + x] = color;
    } else if (bytes_per_pixel == 3) {
        // 24-бит
        buffer[offset] = color & 0xFF;          // Blue
        buffer[offset + 1] = (color >> 8) & 0xFF;  // Green
        buffer[offset + 2] = (color >> 16) & 0xFF; // Red
    } else if (bytes_per_pixel == 2) {
        // 16-бит
        uint16_t* buf16 = (uint16_t*)buffer;
        uint8_t r = (color >> 16) & 0xFF;
        uint8_t g = (color >> 8) & 0xFF;
        uint8_t b = color & 0xFF;
        uint16_t rgb565 = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
        buf16[y * (fb.pitch / 2) + x] = rgb565;
    }
}

color_t vesa_get_pixel(uint32_t x, uint32_t y) {
    if(!fb.found || x >= fb.width || y >= fb.height) return 0;
    
    uint32_t bytes_per_pixel = fb.bpp / 8;
    
    if (double_buffer_enabled && back_buffer) {
        uint8_t* buf = (uint8_t*)back_buffer;
        uint32_t offset = y * fb.pitch + x * bytes_per_pixel;
        
        if (bytes_per_pixel == 4) {
            return ((uint32_t*)buf)[y * (fb.pitch / 4) + x];
        } else if (bytes_per_pixel == 3) {
            uint32_t b = buf[offset];
            uint32_t g = buf[offset + 1];
            uint32_t r = buf[offset + 2];
            return (r << 16) | (g << 8) | b;
        }
    }
    
    return 0;
}

void vesa_draw_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, color_t color) {
    if(!fb.found) return;
    
    uint32_t max_x = (x + w > fb.width) ? fb.width : x + w;
    uint32_t max_y = (y + h > fb.height) ? fb.height : y + h;
    
    for(uint32_t dy = y; dy < max_y; dy++) {
        for(uint32_t dx = x; dx < max_x; dx++) {
            vesa_put_pixel(dx, dy, color);
        }
    }
}

void vesa_draw_line(uint32_t x1, uint32_t y1, uint32_t x2, uint32_t y2, color_t color) {
    if(!fb.found) return;
    
    int dx = (x2 > x1) ? (int)(x2 - x1) : (int)(x1 - x2);
    int dy = (y2 > y1) ? (int)(y2 - y1) : (int)(y1 - y2);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;
    
    while(1) {
        if(x1 < fb.width && y1 < fb.height) {
            vesa_put_pixel(x1, y1, color);
        }
        
        if(x1 == x2 && y1 == y2) break;
        
        int e2 = err * 2;
        if(e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if(e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

void vesa_fill(color_t color) {
    if(!fb.found) return;
    
    if (double_buffer_enabled && back_buffer) {
        vesa_clear_back_buffer(color);
        vesa_mark_dirty_all();
    } else {
        uint32_t bytes_per_pixel = fb.bpp / 8;
        uint8_t* buf = (uint8_t*)fb.address;
        size_t buffer_size = fb.height * fb.pitch;
        
        uint8_t r = (color >> 16) & 0xFF;
        uint8_t g = (color >> 8) & 0xFF;
        uint8_t b = color & 0xFF;
        
        if (bytes_per_pixel == 4) {
            uint32_t* buf32 = (uint32_t*)buf;
            size_t total_pixels = fb.width * fb.height;
            for (size_t i = 0; i < total_pixels; i++) {
                buf32[i] = color;
            }
        } else if (bytes_per_pixel == 3) {
            for (size_t i = 0; i < buffer_size; i += 3) {
                buf[i] = b;
                buf[i + 1] = g;
                buf[i + 2] = r;
            }
        }
    }
}

void vesa_clear(void) {
    vesa_fill(0x000000);
}

// ===== ТЕКСТ =====

static uint16_t utf8_to_unicode(const char** str) {
    uint8_t c = (uint8_t)*(*str)++;
    
    if (c < 0x80) return c;
    if ((c & 0xE0) == 0xC0) {
        uint8_t c2 = (uint8_t)*(*str)++;
        if ((c2 & 0xC0) != 0x80) return '?';
        return ((c & 0x1F) << 6) | (c2 & 0x3F);
    }
    if ((c & 0xF0) == 0xE0) {
        (*str) += 2;
        return '?';
    }
    if ((c & 0xF8) == 0xF0) {
        (*str) += 3;
        return '?';
    }
    return '?';
}

static const uint8_t* get_char_data(uint16_t unicode) {
    if (unicode >= 32 && unicode < 127) {
        return &font_8x16[(unicode - 32) * 16];
    }
    
    if (unicode >= 0x0410 && unicode <= 0x042F) {
        uint16_t index = unicode - 0x0410;
        if (index < 64) return &font_8x16_rus[index * 16];
    }
    
    if (unicode >= 0x0430 && unicode <= 0x044F) {
        uint16_t index = unicode - 0x0430 + 32;
        if (index < 64) return &font_8x16_rus[index * 16];
    }
    
    switch (unicode) {
        case 0x0401: return &font_8x16_rus[6 * 16];
        case 0x0451: return &font_8x16_rus[38 * 16];
        case '\t': case '\r': case '\b': return NULL;
    }
    
    return &font_8x16[('?' - 32) * 16];
}

void vesa_draw_char(uint32_t x, uint32_t y, uint16_t unicode, color_t fg, color_t bg) {
    const uint8_t* char_data = get_char_data(unicode);
    if (!char_data) return;
    
    for (uint8_t cy = 0; cy < 16; cy++) {
        uint8_t byte = char_data[cy];
        for (uint8_t cx = 0; cx < 8; cx++) {
            uint32_t px = x + cx;
            uint32_t py = y + cy;
            
            if (px >= fb.width || py >= fb.height) continue;
            
            if (byte & (1 << (7 - cx))) {
                vesa_put_pixel(px, py, fg);
            }
            else if (bg != 0xFFFFFFFF) {
                vesa_put_pixel(px, py, bg);
            }
        }
    }
}

void vesa_draw_text(uint32_t x, uint32_t y, const char* text, color_t fg, color_t bg) {
    if (!fb.found || !text) return;
    
    uint32_t cx = x;
    uint32_t cy = y;
    const char* ptr = text;
    
    while (*ptr) {
        uint16_t unicode = utf8_to_unicode(&ptr);
        
        if (unicode == '\n') {
            cx = x;
            cy += 16;
        } else if (unicode == '\t') {
            cx = (cx + 32) & ~31;
        } else {
            vesa_draw_char(cx, cy, unicode, fg, bg);
            cx += 8;
            
            if (cx + 8 > fb.width) {
                cx = 0;
                cy += 16;
            }
        }
        
        if (cy + 16 > fb.height) break;
    }
}

void vesa_draw_text_cp866(uint32_t x, uint32_t y, const char* text, color_t fg, color_t bg) {
    if (!fb.found || !text) return;
    
    uint32_t cx = x;
    uint32_t cy = y;
    const char* ptr = text;
    
    while (*ptr) {
        uint8_t c = (uint8_t)*ptr++;
        
        if (c == '\n') {
            cx = x;
            cy += 16;
        } else if (c == '\t') {
            cx = (cx + 32) & ~31;
        } else {
            uint16_t unicode = c;
            if (c >= 0x80 && c <= 0xBF) {
                if (c <= 0x9F) {
                    unicode = 0x0410 + (c - 0x80);
                } else {
                    unicode = 0x0430 + (c - 0xA0);
                }
            }
            vesa_draw_char(cx, cy, unicode, fg, bg);
            cx += 8;
            
            if (cx + 8 > fb.width) {
                cx = 0;
                cy += 16;
            }
        }
        
        if (cy + 16 > fb.height) break;
    }
}

void vesa_draw_text_rus(uint32_t x, uint32_t y, const char* text, color_t fg, color_t bg) {
    vesa_draw_text(x, y, text, fg, bg);
}

// ===== СЛУЖЕБНЫЕ ФУНКЦИИ =====

uint32_t vesa_get_width(void) { return fb.width; }
uint32_t vesa_get_height(void) { return fb.height; }
uint32_t* vesa_get_framebuffer(void) { return fb.address; }
struct fb_info* vesa_get_info(void) { return &fb; }

uint8_t vesa_is_double_buffer_enabled(void) {
    return double_buffer_enabled && (back_buffer != NULL);
}

void* vesa_get_back_buffer(void) {
    return back_buffer;
}

uint8_t vesa_is_background_cached(void) {
    return background_cached;
}